"""
Numerically-controlled oscillator (NCO)
"""

import os
import numpy as np
import matplotlib.pyplot as plt
from utils import sys_
from signal.ca_code import caCode


class NCO:
    '''
    NCO class, contains lookup table (LUT) for sine/cosine
    '''

    bits, length, resolution = None, None, None
    len_lut, lut_sin, lut_cos = None, None, None

    def __init__(self, fs=sys_.fs, bits=32, len_lut=2 ** 8):
        self.bits = bits
        self.length = 2 ** self.bits
        self.resolution = fs / self.length
        self.len_lut = len_lut      # number of quantization levels of sine/cosine, 8 bits
        self.create_lut()

    def generate(self, step, n, phase_in, index_in, len_table):
        '''

        :param step:        frequency control word
        :param n:           number of points to be generated
        :param phase_in:    current nco phase
        :param index_in:    current lookup table index
        :param len_table:   lookup table length
        :return:
            table_indices:  lut indices for each data point, size n
            phase_out:      nco phase output (= previous phase_in)
            index_out:      lookup table index output (= previous index_in)
        '''

        table_indices = [0] * n     # initialize table_indices output

        # phase and index should be larger than 0
        while phase_in < 0:
            phase_in += self.length
            index_in -= 1

        index_in = index_in % len_table

        for i in range(n):
            table_indices[i] = int(index_in)

            phase_in = phase_in + step      # step once

            # phase overflow
            if phase_in >= self.length:
                index_in += phase_in // self.length
                phase_in = phase_in % self.length

            # index overflow
            if index_in >= len_table:
                index_in = index_in % len_table

        return table_indices, phase_in, index_in

    def create_lut(self):
        t = np.arange(0, 2 * np.pi, 2 * np.pi / self.len_lut)
        self.lut_sin = np.sin(t)
        self.lut_cos = np.cos(t)


if __name__ == '__main__':

    # generate a sinusoid signal using NCO
    f_sine = 2e3        # frequency 2 kHz
    duration = 1e-3     # duration 1 ms, thus two periods
    t = np.arange(0, duration, 1 / sys_.fs)
    save_plot = True

    # default setting, 8 bits
    nco = NCO()
    nco_step = f_sine / nco.resolution * nco.len_lut
    indices, _, _ = nco.generate(nco_step, len(t), 0, 0, nco.len_lut)
    signal = nco.lut_sin[indices]
    plt.figure(figsize=(8, 6))
    plt.subplot(211)
    plt.plot(t, signal)
    plt.axis('off')
    plt.title('Sine wave generated by 8-bit LUT')

    # NCO with 6 bits
    nco.len_lut = 2 ** 6
    nco.create_lut()
    nco_step = f_sine / nco.resolution * nco.len_lut
    indices, _, _ = nco.generate(nco_step, len(t), 0, 0, nco.len_lut)
    signal = nco.lut_sin[indices]
    plt.subplot(212)
    plt.plot(t, signal)
    plt.axis('off')
    plt.title('Sine wave generated by 6-bit LUT')

    if save_plot:
        if not os.path.exists('vis'):
            os.makedirs('vis')
        plt.savefig(os.path.join('vis', 'nco_sine.png'), dpi=200)
        plt.close()
    else:
        plt.show()

    # generate C/A code using NCO
    t = np.arange(0, 50 / sys_.f_ca, 1 / sys_.fs)
    code_table = caCode(1).code
    nco_step = sys_.f_ca / nco.resolution
    indices, _, _ = nco.generate(nco_step, len(t), 0, 0, len(code_table))
    signal = code_table[indices]
    plt.figure(figsize=(8, 4))
    plt.plot(t, signal)
    plt.axis('off')
    plt.title('C/A code (display first 50 chips)')
    if save_plot:
        if not os.path.exists('vis'):
            os.makedirs('vis')
        plt.savefig(os.path.join('vis', 'nco_ca.png'), dpi=200)
        plt.close()
    else:
        plt.show()

